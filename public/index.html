<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width:device-width, initial-scale=1" />
    <title>Demo</title>
    <link rel="stylesheet" href="https://unpkg.com/mocha@8/mocha.css" />
    <link rel="stylesheet" href="style.css" />
    <script
      src="https://unpkg.com/react@16/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.js"></script>
    <script src="https://unpkg.com/ionicons@5/dist/ionicons.js"></script>
    <script src="https://unpkg.com/mocha@8/mocha.js"></script>
    <script src="https://unpkg.com/chai@2/chai.js"></script>
  </head>
  <body>
    <!-- <div id="mocha"></div> -->
    <div id="root"></div>

    <script type="text/jsx">
      const SET_TIME = "SET_TIME";
      const SET_LOTS = "SET_LOTS";
      const CHANGE_LOT_PRICE = "CHANGE_LOT_PRICE";
      const FAVORITE_LOT = "FAVORITE_LOT";
      const UNFAVORITE_LOT = "UNFAVORITE_LOT";

      const clockInitialState = {
        time: new Date(),
      };

      const auctionInitialState = {
        lots: null,
      };

      function clockReducer(state = clockInitialState, action) {
        switch (action.type) {
          case SET_TIME:
            return {
              ...state,
              time: action.time,
            };
          default:
            return state;
        }
      }

      function auctionReducer(state = auctionInitialState, action) {
        switch (action.type) {
          case SET_LOTS:
            return {
              ...state,
              lots: action.lots,
            };
          case CHANGE_LOT_PRICE:
            return {
              ...state,
              lots: state.lots.map((lot) =>
                lot.id === action.id ? { ...lot, price: action.price } : lot
              ),
            };
          case FAVORITE_LOT:
            return {
              ...state,
              lots: state.lots.map((lot) =>
                lot.id === action.id ? { ...lot, favorite: true } : lot
              ),
            };
          case UNFAVORITE_LOT:
            return {
              ...state,
              lots: state.lots.map((lot) =>
                lot.id === action.id ? { ...lot, favorite: false } : lot
              ),
            };
          default:
            return state;
        }
      }

      function combineReducers(reducers) {
        return (state = {}, action) => {
          const result = {};
          Object.entries(reducers).forEach(([key, reducer]) => {
            result[key] = reducer(state[key], action);
          });
          return result;
        };
      }

      function setTime(time) {
        return {
          type: SET_TIME,
          time,
        };
      }

      function setLots(lots) {
        return {
          type: SET_LOTS,
          lots,
        };
      }

      function changeLotPrice(id, price) {
        return {
          type: CHANGE_LOT_PRICE,
          id,
          price,
        };
      }

      function favoriteLot(id) {
        return {
          type: FAVORITE_LOT,
          id,
        };
      }

      function unfavoriteLot(id) {
        return {
          type: UNFAVORITE_LOT,
          id,
        };
      }

      class Store {
        constructor(reducer, state) {
          this.reducer = reducer;
          this.state = reducer(state, { type: null });
          this.listeners = [];
        }

        subscribe(callback) {
          this.listeners.push(callback);

          return () => {
            const index = this.listeners.indexOf(callback);
            this.listeners.splice(index, 1);
          };
        }

        getState() {
          return this.state;
        }

        dispatch(action) {
          this.state = this.reducer(this.state, action);
          this.listeners.forEach((listener) => {
            listener();
          });
        }
      }

      const store = new Store(
        combineReducers({
          clock: clockReducer,
          auction: auctionReducer,
        })
      );
      //  ####################################################################

      const StoreContext = React.createContext();

      //  ####################################################################

      const API = {
        get(url) {
          return new Promise((resolve, reject) => {
            if (url === "lots") {
              setTimeout(() => {
                resolve([
                  {
                    id: 1,
                    title: "Apple",
                    description: "Apple description",
                    price: 16,
                    favorite: true,
                  },
                  {
                    id: 2,
                    title: "Orange",
                    description: "Orange description",
                    price: 41,
                    favorite: false,
                  },
                ]);
              }, 1000);
            } else {
              reject(new Error("Uknown address"));
            }
          });
        },

        post(url) {
          if (/^\/lots\/(\d+)\/favorite$/.exec(url)) {
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve();
              }, 500);
            });
          }
          if (/^\/lots\/(\d+)\/unfavorite$/.exec(url)) {
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve();
              }, 500);
            });
          }

          throw new Error("Unknown address");
        },
      };

      const Stream = {
        subscribe(channel, callback) {
          const [, lotId] = channel.split(":");
          setInterval(() => {
            callback({
              id: parseInt(lotId),
              price: Math.floor(Math.random() * 100),
            });
          }, 400);
        },
      };

      //  ####################################################################

      const VDom = {
        createElement: (type, config, ...children) => {
          const props = config || {};
          const key = props.key || null;

          if ((children.length = 1)) {
            props.children = children[0];
          } else {
            props.children = children;
          }

          return {
            type,
            key,
            props,
          };
        },
      };

      //  ####################################################################

      function App() {
        return (
          <div className="app">
            <Header />
            <ClockContainer />
            <LotsContainer />
          </div>
        );
      }

      function Header() {
        return (
          <header className="header">
            <Logo />
          </header>
        );
      }

      function Logo() {
        return <img className="logo" src="logo.png" />;
      }

      function ClockContainer() {
        return (
          <StoreContext.Consumer>
            {(store) => {
              const state = store.getState();
              const time = state.clock.time;

              return <Clock time={time} />;
            }}
          </StoreContext.Consumer>
        );
      }

      function Clock({ time }) {
        const isDay = time.getHours() >= 7 && time.getHours() <= 21;

        return (
          <div className="clock">
            <span className="value">{time.toLocaleTimeString()}</span>
            <span className={isDay ? "icon day" : "icon night"}></span>
          </div>
        );
      }

      function LotsContainer() {
        return (
          <StoreContext.Consumer>
            {(store) => {
              const state = store.getState();
              const lots = state.auction.lots;

              return <Lots lots={lots} />;
            }}
          </StoreContext.Consumer>
        );
      }

      function Lots({ lots }) {
        if (!lots) {
          return <Loading />;
        }

        return (
          <div className="lots">
            {lots.map((lot) => (
              <LotContainer lot={lot} />
            ))}
          </div>
        );
      }

      function LotContainer({ lot }) {
        return (
          <StoreContext.Consumer>
            {(store) => {
              const favorite = (id) => {
                API.post(`/lots/${id}/favorite`).then(() => {
                  store.dispatch(favoriteLot(id));
                });
              };

              const unfavorite = (id) => {
                API.post(`/lots/${id}/unfavorite`).then(() => {
                  store.dispatch(unfavoriteLot(id));
                });
              };

              return (
                <Lot lot={lot} favorite={favorite} unfavorite={unfavorite} />
              );
            }}
          </StoreContext.Consumer>
        );
      }

      function Lot({ lot, favorite, unfavorite }) {
        return (
          <article
            className={"lot" + " " + (lot.favorite ? "favorite" : "")}
            key={lot.id}
          >
            <div className="price">{lot.price}</div>
            <h1>{lot.title}</h1>
            <p>{lot.description}</p>
            <Favorite
              active={isFav(lot)}
              favorite={() => favorite(lot.id)}
              unfavorite={() => unfavorite(lot.id)}
            />
          </article>
        );
      }

      const isFav = (lot) => {
        return lot.favorite;
      };

      function Favorite({ active, favorite, unfavorite }) {
        return active ? (
          <button type="button" className="unfavorite" onClick={unfavorite}>
            <ion-icon name="heart-sharp" />
            Unfavorite
          </button>
        ) : (
          <button type="button" className="favorite" onClick={favorite}>
            <ion-icon name="heart-outline" />
            Favorite
          </button>
        );
      }

      function Loading() {
        return <div className="loading">"Loading..."</div>;
      }

      //  ####################################################################

      function createRealNodeByVirtual(virtual) {
        return typeof virtual !== "object"
          ? document.createTextNode("")
          : document.createElement(virtual.type);
      }

      function sync(virtualNode, realNode) {
        // Sync element
        if (virtualNode.props) {
          Object.entries(virtualNode.props).forEach(([name, value]) => {
            if (name === "children" || name === "key") {
              return;
            }

            if (realNode[name] !== value) {
              realNode[name] = value;
            }
          });
        }

        if (virtualNode.key) {
          realNode.dataset.key = virtualNode.key;
        }

        if (
          typeof virtualNode !== "object" &&
          virtualNode !== realNode.nodeValue
        ) {
          realNode.nodeValue = virtualNode;
        }

        // Sync child nodes
        const virtualChildren = (virtualNode.props || {}).children || [];
        const realChildren = realNode.childNodes;
        for (
          let i = 0;
          i < virtualChildren.length || i < realChildren.length;
          i++
        ) {
          const virtual = virtualChildren[i];
          const real = realChildren[i];

          // Remove
          if (virtual === undefined && real !== undefined) {
            realNode.remove(real);
          }

          // Update
          if (
            virtual !== undefined &&
            real !== undefined &&
            (virtual.type || "") === (real.tagName || "").toLowerCase()
          ) {
            sync(virtual, real);
          }

          // Replace
          if (
            virtual !== undefined &&
            real !== undefined &&
            (virtual.type || "") !== (real.tagName || "").toLowerCase()
          ) {
            const newReal = createRealNodeByVirtual(virtual);
            sync(virtual, newReal);
            realNode.replaceChild(newReal, real);
          }

          // Add
          if (virtual !== undefined && real === undefined) {
            const newReal = createRealNodeByVirtual(virtual);
            sync(virtual, newReal);
            realNode.appendChild(newReal);
          }
        }
      }

      //  ####################################################################

      function render(virtualDom, realDomRoot) {
        const evaluatedVirtualDom = evaluate(virtualDom);

        const virtualDomRoot = {
          type: realDomRoot.tagName.toLowerCase(),
          props: {
            id: realDomRoot.id,
            ...realDomRoot.attributes,
            children: [evaluatedVirtualDom],
          },
        };

        sync(virtualDomRoot, realDomRoot);
      }

      function evaluate(virtualNode) {
        if (typeof virtualNode !== "object") {
          return virtualNode;
        }
        if (typeof virtualNode.type === "function") {
          return evaluate(virtualNode.type(virtualNode.props));
        }

        const props = virtualNode.props || {};

        return {
          ...virtualNode,
          props: {
            ...props,
            children: Array.isArray(props.children)
              ? props.children.map(evaluate)
              : [evaluate(props.children)],
          },
        };
      }

      function renderView(store) {
        ReactDOM.render(
          <StoreContext.Provider value={store}>
            <App />
          </StoreContext.Provider>,
          document.getElementById("root")
        );
      }

      const unsubscribe = store.subscribe(() => {
        renderView(store);
      });

      renderView(store);

      //  ####################################################################

      setInterval(() => {
        store.dispatch(setTime(new Date()));
      }, 1000);

      API.get("lots").then((lots) => {
        store.dispatch(setLots(lots));

        lots.forEach((lot) => {
          Stream.subscribe(`Price:${lot.id}`, (data) => {
            store.dispatch(changeLotPrice(data.id, data.price));
          });
        });
      });
    </script>

    <!-- <script>
      mocha.setup("bdd");
      const assert = chai.assert;

      describe("Clock", () => {
        it("Time of day", () => {
          const container = document.createElement("div");
          render(<Clock time={new Date("2025-05-05T14:12:31")} />, container);

          const clock = container.querySelector(".clock");
          assert.equal(clock.querySelector(".value").innerText, "2:12:31 PM");
          assert.equal(clock.querySelector(".icon").className, "icon day");
        });

        it("Time of night", () => {
          const container = document.createElement("div");
          render(<Clock time={new Date("2025-05-05T03:24:12")} />, container);

          const clock = container.querySelector(".clock");
          assert.equal(clock.querySelector(".value").innerText, "3:24:12 AM");
          assert.equal(clock.querySelector(".icon").className, "icon night");
        });
      });

      mocha.run();
    </script> -->

    <!-- <script>
      function convertToBrowserJs(code) {
        console.log(Babel.transform(code, { presets: ["stage-3"] }).code);
        return Babel.transform(code, { presets: ["stage-3"] }).code;
      }

      const scripts = document.querySelectorAll('script[type="text/own"]');
      scripts.forEach((el) => {
        const js = convertToBrowserJs(el.text);
        const script = document.createElement("script");
        script.text = js;
        document.querySelector("body").append(script);
      });
    </script> -->
  </body>
</html>
